export class BreakevenService {
    constructor(db, config = {}) {
        this.db = db;
        this.defaultCost = config.default_node_cost_usdt_day || 0.40; // ~12$/mo
        this.alertThreshold = config.breakeven_negative_days_alert || 14;
    }

    async runDailyJob() {
        console.log('[Breakeven] Starting daily validaton...');
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yyyymmdd = parseInt(yesterday.toISOString().slice(0, 10).replace(/-/g, ''));

        // 1. Get all nodes that were active yesterday (or just all known nodes)
        const nodes = await this.db.query("SELECT node_id FROM nodes UNION SELECT wallet as node_id FROM registered_nodes");

        let processed = 0;
        for (const { node_id } of nodes) {
            if (!node_id) continue;
            await this.computeDailyStats(node_id, yyyymmdd);
            processed++;
        }
        console.log(`[Breakeven] Processed ${processed} nodes for ${yyyymmdd}`);
    }

    async computeDailyStats(nodeId, yyyymmdd) {
        // Convert yyyymmdd to timestamps
        const dateStr = `${Math.floor(yyyymmdd / 10000)}-${Math.floor((yyyymmdd % 10000) / 100)}-${yyyymmdd % 100}`;
        const start = new Date(dateStr).setUTCHours(0, 0, 0, 0); // UTC midnight
        const end = start + 86400000;

        // 1. Revenue (Real money coming in attributed to this node)
        // Adjust query based on actual schema: revenue_events_v2 might link to node_id?
        // Assuming revenue_events_v2 has 'node_id'. If not, we might need to rely on 'attribution' JSON or similar.
        // Let's assume for now revenue_events_v2 has `node_id`. If M1 schema didn't add it, we might check `clients`.
        // Wait, revenue comes from Clients. Nodes get Rewards.
        // "revenue_usdt = sum revenue_events where node_id" -> Implicitly means revenue ATTRIBUTED to node?
        // Or does it mean Rewards?
        // Requirement: "revenue_usdt = sum revenue_events where node_id"
        // Let's assume there's a way to link revenue to a node (maybe via distributor/partner?). 
        // Or maybe direct "Stream" revenue?
        // In MVP, nodes don't generate direct revenue usually. They get paid FROM revenue.
        // But let's follow the prompt: "sum revenue_events where node_id". 
        // I will interpret this as "Revenue generated by traffic served by this node".
        // If revenue_events_v2 lacks node_id, we might need to join with `request_traces` or similar? 
        // For now, I'll default to 0 if column missing, or check previous schemas.
        // Layer 34 added revenue_events_v2. Let's check schema.

        // checking schema existence lazily or just try access.
        let revenueUsdt = 0;
        try {
            const revRow = await this.db.get(
                `SELECT SUM(amount_usdt) as total FROM revenue_events_v2 WHERE node_id = ? AND created_at >= ? AND created_at < ?`,
                [nodeId, start, end]
            );
            revenueUsdt = revRow?.total || 0;
        } catch (e) {
            // Column might not exist. Ignore for now.
        }

        // 2. Rewards (What we paid the node)
        // Sources: epoch_payouts (if exists) or earnings table.
        // Layer 55: ops_rewards (op_counts, ops_earnings?)
        // Let's use `ops_earnings` or `epoch_earnings`.
        // Prioritize `epoch_earnings` (Layer 4 migration creates it?) -> No, layer 4 creates `epoch_distribution`.
        // Layer 55 adds `ops_rewards`.
        // Let's look for `epoch_earnings` or similar.
        // Common pattern: `epoch_earnings` table.
        let rewardsUsdt = 0;
        try {
            const rewardRow = await this.db.get(
                `SELECT SUM(amount_usdt) as total FROM epoch_earnings WHERE wallet_or_node_id = ? AND created_at >= ? AND created_at < ?`,
                [nodeId, start, end]
            );
            rewardsUsdt = rewardRow?.total || 0;
        } catch (e) { }

        // 3. Costs (Fixed + Override)
        let costUsdt = this.defaultCost;
        const override = await this.db.get("SELECT cost_usdt_day FROM node_cost_overrides WHERE node_id = ?", [nodeId]);
        if (override) {
            costUsdt = override.cost_usdt_day;
        }

        // 4. Net & Margin
        const netUsdt = rewardsUsdt - costUsdt; // from node perspective? 
        // Wait: "revenue_usdt" usually implies Platform Revenue. "rewards_usdt" implies Platform Cost.
        // But prompt says "Per-Node Break-Even".
        // Does it mean "Is the NODE operator making money?" OR "Is the PLATFORM making money on this node?"
        // Formula: "net_usdt = rewards_usdt - cost_usdt".
        // If rewards are what node gets, and cost is node's cost -> Node Profitability.
        // Prompt Check: "You can see which nodes will quit before they quit." -> YES, Node Profitability.

        const marginPct = costUsdt > 0 ? (netUsdt / costUsdt) * 100 : 0;

        // 5. Store
        await this.db.query(`
            INSERT INTO node_econ_daily (day_yyyymmdd, node_id, revenue_usdt, rewards_usdt, cost_usdt, net_usdt, margin_pct, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(day_yyyymmdd, node_id) DO UPDATE SET
                revenue_usdt = excluded.revenue_usdt,
                rewards_usdt = excluded.rewards_usdt,
                cost_usdt = excluded.cost_usdt,
                net_usdt = excluded.net_usdt,
                margin_pct = excluded.margin_pct
        `, [yyyymmdd, nodeId, revenueUsdt, rewardsUsdt, costUsdt, netUsdt, marginPct, Date.now()]);

        // 6. Alert Check (Negative Streak)
        if (netUsdt < 0) {
            // Check previous days
            const streak = await this.checkNegativeStreak(nodeId, yyyymmdd);
            if (streak >= this.alertThreshold) {
                // TODO: Trigger Incident (via callback or return)
                console.warn(`[Breakeven] Node ${nodeId} negative for ${streak} days!`);
            }
        }
    }

    async checkNegativeStreak(nodeId, currentDay) {
        // Simple check: count backwards
        let streak = 1;
        let checkDay = currentDay;

        // Safety limit 30 days lookback
        for (let i = 0; i < 30; i++) {
            // decrement day logic (rough)
            // simplified: actually need date math
            const d = this._prevDay(checkDay);
            const row = await this.db.get("SELECT net_usdt FROM node_econ_daily WHERE node_id = ? AND day_yyyymmdd = ?", [nodeId, d]);
            if (row && row.net_usdt < 0) {
                streak++;
                checkDay = d;
            } else {
                break;
            }
        }
        return streak;
    }

    _prevDay(ymd) {
        // yyyymmdd -> Date -> -1 day -> yyyymmdd
        const y = Math.floor(ymd / 10000);
        const m = Math.floor((ymd % 10000) / 100) - 1; // 0-indexed
        const d = ymd % 100;
        const date = new Date(Date.UTC(y, m, d));
        date.setUTCDate(date.getUTCDate() - 1);
        return parseInt(date.toISOString().slice(0, 10).replace(/-/g, ''));
    }

    async getHistory(nodeId, limit = 30) {
        return await this.db.query(
            "SELECT * FROM node_econ_daily WHERE node_id = ? ORDER BY day_yyyymmdd DESC LIMIT ?",
            [nodeId, limit]
        );
    }

    async getOverview(day) {
        // Stats for specific day or latest
        if (!day) {
            const last = await this.db.get("SELECT MAX(day_yyyymmdd) as d FROM node_econ_daily");
            day = last?.d;
        }
        if (!day) return [];

        return await this.db.query(
            "SELECT * FROM node_econ_daily WHERE day_yyyymmdd = ? ORDER BY net_usdt ASC",
            [day]
        );
    }

    async setCostOverride(nodeId, cost, actor) {
        await this.db.query(`
            INSERT INTO node_cost_overrides (node_id, cost_usdt_day, updated_by, updated_at)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(node_id) DO UPDATE SET
                cost_usdt_day = excluded.cost_usdt_day,
                updated_by = excluded.updated_by,
                updated_at = excluded.updated_at
        `, [nodeId, cost, actor, Date.now()]);
    }
}
