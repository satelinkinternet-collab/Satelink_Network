
export class GrowthEngine {
    constructor(db) {
        this.db = db;
    }

    // ═══════════════════════════════════════════════════════════
    // 34.2 — NODE PROFITABILITY (Hardened)
    // ═══════════════════════════════════════════════════════════

    async calculateNodeProfitability() {
        const now = Date.now();
        const dayAgo = now - 86400000;
        const dateKey = new Date().toISOString().split('T')[0];

        const nodes = await this.db.query(
            "SELECT DISTINCT node_wallet FROM node_uptime WHERE uptime_seconds > 0"
        );

        const report = [];

        for (const n of nodes) {
            const wallet = n.node_wallet;

            // Revenue generated by this node
            const rev = await this.db.get(
                "SELECT SUM(amount_usdt) as t FROM revenue_events_v2 WHERE node_id = ? AND created_at > ?",
                [wallet, dayAgo]
            );
            const revenue = rev?.t || 0;

            // Rewards earned
            const rew = await this.db.get(
                "SELECT SUM(amount) as t FROM payout_items_v2 WHERE wallet = ? AND created_at > ?",
                [wallet, dayAgo]
            );
            const rewards = rew?.t || 0;

            // Op count + success rate
            const opsAll = await this.db.get(
                "SELECT COUNT(*) as total, COUNT(CASE WHEN status = 'success' THEN 1 END) as ok FROM revenue_events_v2 WHERE node_id = ? AND created_at > ?",
                [wallet, dayAgo]
            );
            const opCount = opsAll?.total || 0;
            const successRate = opCount > 0 ? ((opsAll?.ok || 0) / opCount) * 100 : 100;

            // Uptime %
            const uptimeRow = await this.db.get(
                "SELECT uptime_seconds FROM node_uptime WHERE node_wallet = ? ORDER BY epoch_id DESC LIMIT 1",
                [wallet]
            );
            const uptimeSeconds = uptimeRow?.uptime_seconds || 0;
            const uptimePct = Math.min(100, (uptimeSeconds / 86400) * 100);

            // Avg latency (from traces if available, else 0)
            let avgLatency = 0;
            try {
                const latRow = await this.db.get(
                    "SELECT AVG(duration_ms) as avg FROM ops_traces WHERE node_id = ? AND created_at > ?",
                    [wallet, dayAgo]
                );
                avgLatency = latRow?.avg || 0;
            } catch (e) { /* ops_traces table may not exist */ }

            // Infra cost estimate: $0.10/day fixed + $0.00001/op
            const cost = 0.10 + (opCount * 0.00001);
            const netProfit = rewards - cost;

            report.push({
                node: wallet,
                revenue_generated: revenue,
                rewards_earned: rewards,
                uptime_pct: Math.round(uptimePct * 10) / 10,
                op_success_rate: Math.round(successRate * 10) / 10,
                avg_latency_ms: Math.round(avgLatency),
                simulated_net_profit: Math.round(netProfit * 100) / 100,
                op_count: opCount,
                infra_cost: cost
            });
        }

        // Assign rank (descending by net profit)
        report.sort((a, b) => b.simulated_net_profit - a.simulated_net_profit);
        report.forEach((r, i) => { r.rank = i + 1; });

        // Persist snapshot
        for (const r of report) {
            try {
                await this.db.query(`
                    INSERT OR REPLACE INTO node_profitability_daily 
                    (date_key, node_id, revenue_generated, rewards_earned, op_count, infra_cost_est,
                     uptime_pct, success_rate, avg_latency_ms, rank, net_profit)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [dateKey, r.node, r.revenue_generated, r.rewards_earned, r.op_count, r.infra_cost,
                    r.uptime_pct, r.op_success_rate, r.avg_latency_ms, r.rank, r.simulated_net_profit]);
            } catch (e) { /* ignore persist errors */ }
        }

        return report;
    }

    /**
     * Check Attrition Risk: nodes with negative profit > 3 consecutive days → incident
     */
    async checkAttritionRisk() {
        const alerts = [];
        const threeDaysAgo = new Date(Date.now() - 3 * 86400000).toISOString().split('T')[0];

        const atRisk = await this.db.query(`
            SELECT node_id, COUNT(*) as bad_days, AVG(net_profit) as avg_loss
            FROM node_profitability_daily
            WHERE date_key >= ? AND net_profit < 0
            GROUP BY node_id
            HAVING bad_days >= 3
        `, [threeDaysAgo]);

        for (const node of atRisk) {
            alerts.push({
                node_id: node.node_id,
                bad_days: node.bad_days,
                avg_daily_loss: Math.round(node.avg_loss * 100) / 100
            });

            // Create incident
            try {
                await this.db.query(`
                    INSERT INTO incident_bundles (id, kind, title, severity, status, created_at, summary)
                    VALUES (?, 'attrition_risk', ?, 'warning', 'open', ?, ?)
                `, [
                    `ATTRITION-${node.node_id}-${Date.now()}`,
                    `Node attrition risk: ${node.node_id}`,
                    Date.now(),
                    `Node ${node.node_id} has been unprofitable for ${node.bad_days} consecutive days (avg loss: $${Math.abs(node.avg_loss).toFixed(4)}/day). At risk of leaving the network.`
                ]);
            } catch (e) { /* ignore duplicate incidents */ }
        }

        return { at_risk_nodes: alerts.length, alerts };
    }

    // ═══════════════════════════════════════════════════════════
    // 34.3 — DISTRIBUTOR COMMISSIONS (Hardened)
    // ═══════════════════════════════════════════════════════════

    async processCommissions() {
        const now = Date.now();
        const results = [];
        const dateKey = new Date().toISOString().split('T')[0];

        const referrals = await this.db.query("SELECT * FROM conversions");

        for (const ref of referrals) {
            const uptime = await this.db.get(
                "SELECT uptime_seconds FROM node_uptime WHERE node_wallet = ? ORDER BY epoch_id DESC LIMIT 1",
                [ref.node_id]
            );

            if (uptime && uptime.uptime_seconds > 0) {
                // Per-distributor rate (lookup or default 5%)
                const distConfig = await this.db.get(
                    "SELECT commission_rate, daily_cap FROM distributor_commissions WHERE distributor_wallet = ? ORDER BY created_at DESC LIMIT 1",
                    [ref.wallet]
                );
                const rate = distConfig?.commission_rate || 0.05;
                const dailyCap = distConfig?.daily_cap || 50.0;

                // Revenue this node generated today
                const dayAgo = now - 86400000;
                const nodeRev = await this.db.get(
                    "SELECT SUM(amount_usdt) as t FROM revenue_events_v2 WHERE node_id = ? AND created_at > ?",
                    [ref.node_id, dayAgo]
                );
                const nodeRevenue = nodeRev?.t || 0;
                const amount = Math.round(nodeRevenue * rate * 100) / 100;

                if (amount <= 0) continue;

                // Enforce daily cap
                const todayTotal = await this.db.get(
                    "SELECT SUM(amount_usdt) as t FROM distributor_commissions WHERE distributor_wallet = ? AND created_at > ?",
                    [ref.wallet, dayAgo]
                );
                if ((todayTotal?.t || 0) + amount > dailyCap) continue;

                const id = `COMM-${ref.id}-${dateKey}`;
                try {
                    await this.db.query(`
                        INSERT INTO distributor_commissions 
                        (id, distributor_wallet, source_event_id, amount_usdt, status, fraud_flag, commission_rate, daily_cap, created_at)
                        VALUES (?, ?, ?, ?, 'accrued', 0, ?, ?, ?)
                    `, [id, ref.wallet, `active_node_${ref.node_id}`, amount, rate, dailyCap, now]);
                    results.push({ distributor: ref.wallet, amount, rate });
                } catch (e) { /* ignore duplicates */ }
            }
        }
        return { processed: results.length, commissions: results };
    }

    async getCommissionsStats() {
        const total = await this.db.get("SELECT SUM(amount_usdt) as t FROM distributor_commissions WHERE fraud_flag = 0");
        const byDistributor = await this.db.query(`
            SELECT distributor_wallet, 
                   SUM(amount_usdt) as total, 
                   COUNT(*) as count,
                   AVG(commission_rate) as avg_rate,
                   MAX(fraud_score) as fraud_score
            FROM distributor_commissions 
            GROUP BY distributor_wallet 
            ORDER BY total DESC
        `);
        return { total_accrued: total?.t || 0, distributors: byDistributor };
    }

    /**
     * Detect Commission Fraud (Hardened)
     * Checks: self-referral, activation spikes, multi-wallet patterns
     */
    async detectCommissionFraud() {
        const now = Date.now();
        const fraudAlerts = [];
        const dayAgo = now - 86400000;

        // 1. Self-Referral (wallet matches node wallet)
        const selfRefs = await this.db.query("SELECT * FROM conversions WHERE wallet = node_id");
        for (const fraud of selfRefs) {
            fraudAlerts.push({
                type: 'self_referral',
                severity: 'high',
                wallet: fraud.wallet,
                detail: `Distributor ${fraud.wallet} referred themselves as node ${fraud.node_id}`
            });
            await this.db.query(
                "UPDATE distributor_commissions SET fraud_flag = 1, fraud_score = MAX(fraud_score, 80) WHERE distributor_wallet = ?",
                [fraud.wallet]
            );
        }

        // 2. Activation Spikes (> 10 nodes in 24h)
        const spikes = await this.db.query(`
            SELECT wallet, COUNT(*) as c 
            FROM conversions 
            WHERE created_at > ? 
            GROUP BY wallet 
            HAVING c > 10
        `, [dayAgo]);
        for (const s of spikes) {
            fraudAlerts.push({
                type: 'activation_spike',
                severity: 'medium',
                wallet: s.wallet,
                detail: `${s.c} node activations in 24h from distributor ${s.wallet}`
            });
            await this.db.query(
                "UPDATE distributor_commissions SET fraud_score = MAX(fraud_score, 50) WHERE distributor_wallet = ?",
                [s.wallet]
            );
        }

        // 3. Multi-wallet patterns (same distributor name/meta appearing with multiple wallets)
        // Heuristic: look for wallets that refer the exact same set of nodes
        const dupes = await this.db.query(`
            SELECT node_id, COUNT(DISTINCT wallet) as wallets
            FROM conversions
            GROUP BY node_id
            HAVING wallets > 1
        `);
        for (const d of dupes) {
            fraudAlerts.push({
                type: 'multi_wallet',
                severity: 'medium',
                detail: `Node ${d.node_id} referred by ${d.wallets} different distributor wallets — possible sybil`
            });
        }

        return { alerts: fraudAlerts, total_flags: fraudAlerts.length };
    }

    /**
     * Get Distributor Performance (for /admin/distributors/performance)
     */
    async getDistributorPerformance() {
        const dayAgo = Date.now() - 86400000;

        const distributors = await this.db.query(`
            SELECT 
                c.wallet as distributor_wallet,
                COUNT(DISTINCT c.node_id) as referrals,
                COUNT(DISTINCT CASE WHEN nu.uptime_seconds > 0 THEN c.node_id END) as activated_nodes,
                COALESCE(SUM(rev.rev), 0) as revenue_contributed,
                COALESCE(comm.total_earned, 0) as commission_earned,
                COALESCE(comm.fraud_score, 0) as fraud_score
            FROM conversions c
            LEFT JOIN node_uptime nu ON nu.node_wallet = c.node_id
            LEFT JOIN (
                SELECT node_id, SUM(amount_usdt) as rev 
                FROM revenue_events_v2 
                WHERE created_at > ?
                GROUP BY node_id
            ) rev ON rev.node_id = c.node_id
            LEFT JOIN (
                SELECT distributor_wallet, SUM(amount_usdt) as total_earned, MAX(fraud_score) as fraud_score
                FROM distributor_commissions
                GROUP BY distributor_wallet
            ) comm ON comm.distributor_wallet = c.wallet
            GROUP BY c.wallet
            ORDER BY revenue_contributed DESC
        `, [dayAgo]);

        return distributors;
    }

    // ═══════════════════════════════════════════════════════════
    // 34.4 — NODE ACQUISITION TRACKER
    // ═══════════════════════════════════════════════════════════

    async trackAcquisition() {
        const now = Date.now();
        const thirtyDaysAgo = now - (30 * 86400000);
        const sevenDaysAgo = now - (7 * 86400000);

        // CAC = Total Commissions / Nodes Activated
        const totalCommissions30 = (await this.db.get(
            "SELECT SUM(amount_usdt) as t FROM distributor_commissions WHERE created_at > ? AND fraud_flag = 0",
            [thirtyDaysAgo]
        ))?.t || 0;
        const nodesActivated30 = (await this.db.get(
            "SELECT COUNT(*) as c FROM conversions WHERE created_at > ?",
            [thirtyDaysAgo]
        ))?.c || 0;
        const cac = nodesActivated30 > 0 ? totalCommissions30 / nodesActivated30 : 0;

        // LTV = Avg Daily Revenue per Node * Avg Lifespan (180d estimate)
        const dailyRev = (await this.db.get(
            "SELECT AVG(revenue_generated) as avg FROM node_profitability_daily WHERE date_key > ?",
            [new Date(thirtyDaysAgo).toISOString().split('T')[0]]
        ))?.avg || 0;
        const ltv = dailyRev * 180;

        // Churn: nodes NOT seen recently vs total
        const totalNodes = (await this.db.get("SELECT COUNT(*) as c FROM registered_nodes"))?.c || 0;
        const activeNodes = (await this.db.get(
            "SELECT COUNT(DISTINCT node_wallet) as c FROM node_uptime WHERE epoch_id = (SELECT MAX(id) FROM epochs)"
        ))?.c || 0;
        const churnRate = totalNodes > 0 ? ((totalNodes - activeNodes) / totalNodes) * 100 : 0;

        // Payback period
        const paybackDays = dailyRev > 0 ? cac / dailyRev : 0;

        return {
            period: '30d',
            cac: Math.round(cac * 100) / 100,
            ltv: Math.round(ltv * 100) / 100,
            churn_rate: Math.round(churnRate * 10) / 10,
            payback_days: Math.round(paybackDays),
            nodes_activated: nodesActivated30,
            total_nodes: totalNodes,
            active_nodes: activeNodes,
            spend: Math.round(totalCommissions30 * 100) / 100
        };
    }

    // ═══════════════════════════════════════════════════════════
    // 34.5 — UNIT ECONOMICS ENGINE (Hardened: 7d / 30d + break-even)
    // ═══════════════════════════════════════════════════════════

    async analyzeUnitEconomics(period = '7d') {
        const now = Date.now();
        const days = period === '30d' ? 30 : 7;
        const cutoff = now - (days * 86400000);
        const dateKey = new Date().toISOString().split('T')[0];

        const totalRev = (await this.db.get(
            "SELECT SUM(amount_usdt) as t FROM revenue_events_v2 WHERE created_at > ?",
            [cutoff]
        ))?.t || 0;
        const totalRew = (await this.db.get(
            "SELECT SUM(total_amount) as t FROM payout_batches_v2 WHERE created_at > ?",
            [cutoff]
        ))?.t || 0;
        let activeNodes = 0;
        try {
            activeNodes = (await this.db.get(
                "SELECT COUNT(DISTINCT node_id) as c FROM node_heartbeats WHERE timestamp > ?",
                [cutoff]
            ))?.c || 0;
        } catch (e) {
            // Fallback: use node_uptime
            activeNodes = (await this.db.get(
                "SELECT COUNT(DISTINCT node_wallet) as c FROM node_uptime WHERE uptime_seconds > 0"
            ))?.c || 0;
        }

        const burnRate = totalRew - totalRev; // positive = burning
        const margin = totalRev > 0 ? ((totalRev - totalRew) / totalRev) * 100 : 0;
        const avgRevPerNode = activeNodes > 0 ? totalRev / activeNodes : 0;
        const avgRewPerNode = activeNodes > 0 ? totalRew / activeNodes : 0;

        // Break-even: how many nodes needed for revenue >= rewards
        // If avgRevPerNode > avgRewPerNode, we're profitable per node
        const breakEvenNodes = avgRevPerNode > 0 && avgRewPerNode > avgRevPerNode
            ? Math.ceil(totalRew / avgRevPerNode)
            : activeNodes;

        // Persist daily
        try {
            await this.db.query(`
                INSERT OR REPLACE INTO unit_economics_daily
                (date_key, total_revenue, total_rewards, total_nodes_active, burn_rate, avg_margin_percent, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [dateKey, totalRev, totalRew, activeNodes, burnRate, margin, now]);
        } catch (e) { /* soft fail */ }

        // Auto-protect: if burn > threshold → incident + optional rewards_mode switch
        const BURN_THRESHOLD = 100; // $100 in period
        let autoProtectTriggered = false;
        if (burnRate > BURN_THRESHOLD) {
            try {
                await this.db.query(`
                    INSERT INTO incident_bundles (id, kind, title, severity, status, created_at, summary)
                    VALUES (?, 'unsustainable_economics', ?, 'critical', 'open', ?, ?)
                `, [
                    `BURN-${dateKey}`,
                    `Unsustainable economics: burn rate $${burnRate.toFixed(2)}/${period}`,
                    now,
                    `Burn rate of $${burnRate.toFixed(2)} over ${period} exceeds threshold of $${BURN_THRESHOLD}. Revenue: $${totalRev.toFixed(2)}, Rewards: $${totalRew.toFixed(2)}. Consider switching to SIMULATED rewards.`
                ]);
            } catch (e) { /* ignore duplicate */ }

            // Auto set rewards_mode = SIMULATED
            try {
                await this.db.query(
                    "INSERT OR REPLACE INTO system_config (key, value, updated_at) VALUES ('rewards_mode', 'SIMULATED', ?)",
                    [now]
                );
                autoProtectTriggered = true;
            } catch (e) { /* soft */ }
        }

        return {
            period,
            total_revenue: Math.round(totalRev * 100) / 100,
            total_rewards: Math.round(totalRew * 100) / 100,
            burn_rate: Math.round(burnRate * 100) / 100,
            net_margin_pct: Math.round(margin * 10) / 10,
            avg_revenue_per_node: Math.round(avgRevPerNode * 10000) / 10000,
            avg_reward_per_node: Math.round(avgRewPerNode * 10000) / 10000,
            break_even_node_count: breakEvenNodes,
            active_nodes: activeNodes,
            auto_protect_triggered: autoProtectTriggered
        };
    }

    // ═══════════════════════════════════════════════════════════
    // 35.4 — TIERED REFERRAL ENGINE
    // ═══════════════════════════════════════════════════════════

    /**
     * Process tiered commissions:
     *  - Level 1 (direct): 5%
     *  - Level 2 (referral's referral): 2%
     *  - Depth cap: max 2 levels
     *  - Per-node cap: $5/day
     *  - Decay: commission halves after 90 days
     */
    async processTieredCommissions() {
        const now = Date.now();
        const dayAgo = now - 86400000;
        const dateKey = new Date().toISOString().split('T')[0];
        const results = [];

        const TIER_RATES = { 1: 0.05, 2: 0.02 };
        const MAX_DEPTH = 2;
        const MAX_PER_NODE_DAILY = 5.0;
        const DECAY_DAYS = 90;

        // Get all active referrals
        let referrals = [];
        try {
            referrals = await this.db.query("SELECT * FROM conversions") || [];
        } catch (e) { return { processed: 0, commissions: [] }; }

        for (const ref of referrals) {
            // Check node is active
            const uptime = await this.db.get(
                "SELECT uptime_seconds FROM node_uptime WHERE node_wallet = ? ORDER BY epoch_id DESC LIMIT 1",
                [ref.node_id]
            );
            if (!uptime || uptime.uptime_seconds <= 0) continue;

            // Revenue this node generated today
            const nodeRev = await this.db.get(
                "SELECT SUM(amount_usdt) as t FROM revenue_events_v2 WHERE node_id = ? AND created_at > ?",
                [ref.node_id, dayAgo]
            );
            const nodeRevenue = nodeRev?.t || 0;
            if (nodeRevenue <= 0) continue;

            // Process up to MAX_DEPTH tiers
            let currentReferrer = ref.wallet;
            for (let tier = 1; tier <= MAX_DEPTH; tier++) {
                if (!currentReferrer) break;

                const tierRate = TIER_RATES[tier] || 0;
                let amount = Math.round(nodeRevenue * tierRate * 100) / 100;

                // Decay: if referral is older than DECAY_DAYS, halve
                const refAge = (now - (ref.created_at || now)) / (86400000);
                if (refAge > DECAY_DAYS) {
                    amount = Math.round(amount * 0.5 * 100) / 100;
                }

                // Per-node daily cap
                const todayNodeTotal = await this.db.get(
                    "SELECT SUM(amount_usdt) as t FROM distributor_commissions WHERE distributor_wallet = ? AND source_event_id LIKE ? AND created_at > ?",
                    [currentReferrer, `%${ref.node_id}%`, dayAgo]
                );
                if ((todayNodeTotal?.t || 0) + amount > MAX_PER_NODE_DAILY) continue;

                // Overall daily cap
                const distConfig = await this.db.get(
                    "SELECT daily_cap FROM distributor_commissions WHERE distributor_wallet = ? ORDER BY created_at DESC LIMIT 1",
                    [currentReferrer]
                );
                const dailyCap = distConfig?.daily_cap || 50.0;
                const todayTotal = await this.db.get(
                    "SELECT SUM(amount_usdt) as t FROM distributor_commissions WHERE distributor_wallet = ? AND created_at > ?",
                    [currentReferrer, dayAgo]
                );
                if ((todayTotal?.t || 0) + amount > dailyCap) continue;

                if (amount <= 0) continue;

                const id = `TCOMM-T${tier}-${ref.id}-${dateKey}`;
                try {
                    await this.db.query(`
                        INSERT INTO distributor_commissions 
                        (id, distributor_wallet, source_event_id, amount_usdt, status, fraud_flag, 
                         commission_rate, daily_cap, tier_level, referral_depth, decay_days, created_at)
                        VALUES (?, ?, ?, ?, 'accrued', 0, ?, ?, ?, ?, ?, ?)
                    `, [id, currentReferrer, `tier${tier}_node_${ref.node_id}`, amount, tierRate, dailyCap,
                        tier, tier - 1, DECAY_DAYS, now]);
                    results.push({ distributor: currentReferrer, tier, amount, node: ref.node_id });
                } catch (e) { /* ignore duplicates */ }

                // Walk up the referral tree for next tier
                const parent = await this.db.get(
                    "SELECT parent_referrer FROM distributor_commissions WHERE distributor_wallet = ? AND parent_referrer IS NOT NULL LIMIT 1",
                    [currentReferrer]
                );
                currentReferrer = parent?.parent_referrer || null;
            }
        }
        return { processed: results.length, commissions: results };
    }

    /** Detect circular referrals (A→B→C→A) */
    async detectCircularReferrals() {
        const alerts = [];
        try {
            const referrals = await this.db.query(
                "SELECT DISTINCT distributor_wallet, parent_referrer FROM distributor_commissions WHERE parent_referrer IS NOT NULL"
            ) || [];

            // Build adjacency map
            const graph = {};
            for (const r of referrals) {
                graph[r.distributor_wallet] = r.parent_referrer;
            }

            // DFS cycle detection
            for (const start of Object.keys(graph)) {
                const visited = new Set();
                let current = start;
                while (current && graph[current]) {
                    if (visited.has(current)) {
                        alerts.push({
                            type: 'circular_referral',
                            chain: Array.from(visited),
                            severity: 'critical'
                        });
                        break;
                    }
                    visited.add(current);
                    current = graph[current];
                }
            }
        } catch (e) { /* table may not have parent_referrer yet */ }

        return {
            total_circular: alerts.length,
            alerts: alerts.slice(0, 50)
        };
    }

    /** Detect activation spike anomalies (>3x average in 1 hour) */
    async detectActivationSpike() {
        try {
            const hourAgo = Date.now() - 3600000;
            const recentActivations = (await this.db.get(
                "SELECT COUNT(*) as c FROM conversions WHERE created_at > ?", [hourAgo]
            ))?.c || 0;

            const avgHourly = (await this.db.get(
                "SELECT COUNT(*) * 1.0 / (MAX(1, (MAX(created_at) - MIN(created_at)) / 3600000)) as avg FROM conversions"
            ))?.avg || 1;

            const isSpike = recentActivations > avgHourly * 3;
            return {
                recent_activations: recentActivations,
                avg_hourly: Math.round(avgHourly * 100) / 100,
                is_spike: isSpike,
                severity: isSpike ? 'warning' : 'ok'
            };
        } catch (e) {
            return { recent_activations: 0, avg_hourly: 0, is_spike: false, severity: 'ok' };
        }
    }
}
